<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GePetris</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Press Start 2P', cursive; background: linear-gradient(135deg,#0d1117,#161b22); color: white; }
    .tetris-grid{ border:4px solid #4a5568; border-radius:8px; box-shadow:0 0 20px rgba(74,85,104,0.4); display:block; background:#000; }
    .tetris-panel{ background:#161b22; border:2px solid #4a5568; border-radius:8px; }
    #tetrisBanner,#tripleBanner{ color:#FFE138; text-shadow:-2px -2px 0 #FF8E0D,2px -2px 0 #FF8E0D,-2px 2px 0 #FF8E0D,2px 2px 0 #FF8E0D,-3px -3px 0 #FF0D72,3px -3px 0 #FF0D72,-3px 3px 0 #FF0D72,3px 3px 0 #FF0D72; opacity:0; transform:translateY(-8px) scale(0.85); transition:all .45s cubic-bezier(.2,1,.2,1); pointer-events:none; }
    #tetrisBanner.show,#tripleBanner.show{ opacity:1; transform:translateY(0) scale(1); }
    .flash{ animation: flash .12s ease-in-out 2; }
    @keyframes flash{ 0%,100%{ filter:brightness(1); } 50%{ filter:brightness(1.35); } }
    #gpStatus { position: fixed; right: 12px; bottom: 8px; font-family: monospace; font-size: 12px; opacity: 0.75; color: #ddd; }
    footer { position: fixed; bottom: 8px; left: 12px; font-size: 10px; color: #aaa; }
    button:disabled{ opacity:.6; cursor:not-allowed; }
  </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">
  <div class="w-full max-w-4xl mx-auto flex flex-col lg:flex-row gap-4">
    <!-- Left -->
    <div class="w-full lg:w-1/4 flex flex-row lg:flex-col gap-4">
      <div class="tetris-panel p-4 w-1/2 lg:w-full text-center">
        <h2 class="text-lg mb-2">HOLD</h2>
        <canvas id="holdCanvas" width="120" height="120" class="mx-auto bg-black rounded-md"></canvas>
      </div>
      <div class="tetris-panel p-4 w-1/2 lg:w-full text-center">
        <h2 class="text-lg mb-2">SCORE</h2>
        <p id="score" class="text-2xl">0</p>
        <h2 class="text-lg mt-4 mb-2">BEST</h2>
        <p id="highScore" class="text-2xl">0</p>
        <h2 class="text-lg mt-4 mb-2">LINES</h2>
        <p id="lines" class="text-2xl">0</p>
      </div>
    </div>

    <!-- Center -->
    <div class="relative">
      <canvas id="tetris" width="300" height="600" class="tetris-grid"></canvas>
      <div id="pauseOverlay" class="absolute inset-0 bg-black bg-opacity-75 flex items-center justify-center text-4xl hidden">PAUSED</div>
      <div id="gameOverOverlay" class="absolute inset-0 bg-black bg-opacity-75 flex flex-col items-center justify-center text-4xl hidden">
        <p>GAME OVER</p>
        <button id="restartButton" class="tetris-button bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded mt-4 text-lg">RESTART</button>
      </div>
      <div id="tetrisBanner" class="absolute inset-0 flex items-start justify-center pt-8 text-4xl font-bold">Boom! Tetris!</div>
      <div id="tripleBanner" class="absolute inset-0 flex items-start justify-center pt-12 text-3xl font-bold">Triple Clear!</div>
    </div>

    <!-- Right -->
    <div class="w-full lg:w-1/4 flex flex-col gap-4">
      <div class="tetris-panel p-4 text-center">
        <h2 class="text-lg mb-2">NEXT</h2>
        <canvas id="nextCanvas" width="120" height="120" class="mx-auto bg-black rounded-md"></canvas>
      </div>
      <div class="tetris-panel p-4">
        <h2 class="text-lg mb-3 text-center">CONTROLS</h2>
        <div class="flex flex-col gap-4">
          <button id="startButton" class="tetris-button bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded">START</button>
          <button id="pauseButton" class="tetris-button bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-4 rounded" disabled>PAUSE</button>
        </div>
        <div class="text-xs mt-4 space-y-2 text-gray-400">
          <p><span class="font-bold text-white">D-PAD:</span> Move / Soft Drop</p>
          <p><span class="font-bold text-white">A:</span> Rotate CW</p>
          <p><span class="font-bold text-white">B:</span> Rotate CCW</p>
          <p><span class="font-bold text-white">Y:</span> Hold Piece</p>
          <p><span class="font-bold text-white">X:</span> Hard Drop (to Ghost)</p>
          <p><span class="font-bold text-white">SELECT:</span> Pause</p>
          <p><span class="font-bold text-white">START:</span> Restart Game</p>
        </div>
      </div>
    </div>
  </div>

  <div id="gpStatus">ðŸŽ® No Controller</div>
  <footer>Vibe-Coded by: Pranav Kulkarni aka eLaNTRa</footer>

<script>
/* ====================== SOUND ENGINE ====================== */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function ensureAudio() { if (!audioCtx) audioCtx = new AudioCtx(); }
function tone(freq=440, durMs=120, type="square", vol=0.25, when=0) {
  ensureAudio();
  const t0 = audioCtx.currentTime + when;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = type;
  osc.frequency.setValueAtTime(freq, t0);
  gain.gain.setValueAtTime(0, t0);
  gain.gain.linearRampToValueAtTime(vol, t0 + 0.01);
  gain.gain.exponentialRampToValueAtTime(0.0001, t0 + durMs/1000);
  osc.connect(gain).connect(audioCtx.destination);
  osc.start(t0);
  osc.stop(t0 + durMs/1000 + 0.02);
}
function playLineClear(n) {
  const base = 440;
  if (n === 1) {
    tone(base*1.1, 110, "square", 0.25, 0);
  } else if (n === 2) {
    tone(base, 100, "square", 0.22, 0);
    tone(base*1.25, 120, "square", 0.25, 0.12);
  } else if (n === 3) {
    tone(base*0.9, 90, "square", 0.22, 0);
    tone(base*1.1, 90, "square", 0.22, 0.11);
    tone(base*1.35, 110, "square", 0.24, 0.22);
  } else if (n === 4) {
    tone(70, 280, "sawtooth", 0.5, 0);     // boom
    tone(140, 90, "square", 0.18, 0.05);   // click
  }
}

/* ====================== TETRIS CORE ====================== */
const canvas = document.getElementById("tetris");
const ctx = canvas.getContext("2d");
const nextCanvas = document.getElementById("nextCanvas");
const nextCtx = nextCanvas.getContext("2d");
const holdCanvas = document.getElementById("holdCanvas");
const holdCtx = holdCanvas.getContext("2d");

const scoreEl = document.getElementById("score");
const highScoreEl = document.getElementById("highScore");
const linesEl = document.getElementById("lines");
const pauseOverlay = document.getElementById("pauseOverlay");
const gameOverOverlay = document.getElementById("gameOverOverlay");
const restartButton = document.getElementById("restartButton");
const pauseButton = document.getElementById("pauseButton");
const startButton = document.getElementById("startButton");
const tetrisBanner = document.getElementById("tetrisBanner");
const tripleBanner = document.getElementById("tripleBanner");
const gpStatus = document.getElementById("gpStatus");

const COLS=10, ROWS=20, SIZE=30;
const MINI = 24; // next/hold block size
const COLORS=["#000",
  "#FF0D72", // 1
  "#0DC2FF", // 2
  "#0DFF72", // 3
  "#F538FF", // 4
  "#FF8E0D", // 5
  "#FFE138", // 6
  "#3877FF"  // 7
];
// Tetrominoes 1..7
const SHAPES = {
  1: [[1,1,1,1]],                      // I
  2: [[2,2],[2,2]],                    // O
  3: [[0,3,0],[3,3,3]],                // T
  4: [[0,4,4],[4,4,0]],                // S
  5: [[5,5,0],[0,5,5]],                // Z
  6: [[6,0,0],[6,6,6]],                // J
  7: [[0,0,7],[7,7,7]],                // L
};

function cloneShape(s){ return s.map(r=>r.slice()); }

let board, piece, nextPiece, holdType=null, canHold=true;
let score=0, highScore = Number(localStorage.getItem("gepetris_high")||0), lines=0;
let isPaused=false, isGameOver=false;
let dropCounter=0, dropInterval=700 /* safe start */, lastTime=0;

function resetBoard(){ board = Array.from({length:ROWS},()=>Array(COLS).fill(0)); }
function randType(){ return 1 + Math.floor(Math.random()*7); }
function newPiece(type){ return { type, shape: cloneShape(SHAPES[type]), x:3, y:0 }; }

function drawBlock(ctx2, x, y, colorIndex, size=SIZE){
  ctx2.fillStyle = COLORS[colorIndex];
  ctx2.fillRect(x*size, y*size, size, size);
  ctx2.strokeStyle = "#111";
  ctx2.strokeRect(x*size, y*size, size, size);
}
function drawBoard(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      if(board[y][x]) drawBlock(ctx, x, y, board[y][x], SIZE);
    }
  }
}
function drawPiece(p){
  p.shape.forEach((row, dy) => row.forEach((v, dx)=>{
    if(v && p.y+dy>=0) drawBlock(ctx, p.x+dx, p.y+dy, v, SIZE);
  }));
}
function drawGhost(p){
  const g = { x:p.x, y:p.y, shape:p.shape, type:p.type };
  while(!collides({ ...g, y:g.y+1 })) g.y++;
  ctx.save();
  ctx.globalAlpha = 0.25;
  g.shape.forEach((row, dy) => row.forEach((v, dx)=>{
    if(v && g.y+dy>=0) drawBlock(ctx, g.x+dx, g.y+dy, v, SIZE);
  }));
  ctx.restore();
}
function drawNext(){
  nextCtx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
  const s = SHAPES[nextPiece.type];
  const w = s[0].length, h = s.length;
  const offX = Math.floor((nextCanvas.width - w*MINI)/2);
  const offY = Math.floor((nextCanvas.height - h*MINI)/2);
  s.forEach((row, y)=>row.forEach((v,x)=>{ if(v){
    nextCtx.fillStyle = COLORS[v];
    nextCtx.fillRect(offX + x*MINI, offY + y*MINI, MINI, MINI);
    nextCtx.strokeStyle="#111";
    nextCtx.strokeRect(offX + x*MINI, offY + y*MINI, MINI, MINI);
  }}));
}
function drawHold(){
  holdCtx.clearRect(0,0,holdCanvas.width,holdCanvas.height);
  if(holdType==null) return;
  const s = SHAPES[holdType];
  const w = s[0].length, h = s.length;
  const offX = Math.floor((holdCanvas.width - w*MINI)/2);
  const offY = Math.floor((holdCanvas.height - h*MINI)/2);
  s.forEach((row, y)=>row.forEach((v,x)=>{ if(v){
    holdCtx.fillStyle = COLORS[v];
    holdCtx.fillRect(offX + x*MINI, offY + y*MINI, MINI, MINI);
    holdCtx.strokeStyle="#111";
    holdCtx.strokeRect(offX + x*MINI, offY + y*MINI, MINI, MINI);
  }}));
}

function collides(p){
  return p.shape.some((row, dy)=>row.some((v, dx)=>{
    if(!v) return false;
    const nx = p.x + dx, ny = p.y + dy;
    if(nx<0 || nx>=COLS || ny>=ROWS) return true;
    if(ny<0) return false; // allow entering from above
    return !!board[ny][nx];
  }));
}
function merge(p){
  p.shape.forEach((row, dy)=>row.forEach((v,dx)=>{
    const ny = p.y+dy, nx=p.x+dx;
    if(v && ny>=0) board[ny][nx] = v;
  }));
}

/* ===== Rotation with basic wall kicks ===== */
function rotateCWMatrix(s){ return s[0].map((_,i)=>s.map(r=>r[i]).reverse()); }
function rotateCCWMatrix(s){ return s[0].map((_,i)=>s.map(r=>r[r.length-1-i])); }
function tryRotate(newShape){
  const tests = [ [0,0], [1,0], [-1,0], [2,0], [-2,0], [0,-1] ];
  for(const [ox,oy] of tests){
    const test = { ...piece, x: piece.x+ox, y: piece.y+oy, shape: newShape };
    if(!collides(test)) { piece.x += ox; piece.y += oy; piece.shape = newShape; return true; }
  }
  return false;
}
function rotateCW(){ const rot = rotateCWMatrix(piece.shape.map(r=>r.slice())); tryRotate(rot); }
function rotateCCW(){ const rot = rotateCCWMatrix(piece.shape.map(r=>r.slice())); tryRotate(rot); }

/* ===== Movement ===== */
function movePiece(dx){ if(!collides({...piece, x: piece.x+dx})) piece.x += dx; }
function softDropOnce(){ if(!collides({...piece, y: piece.y+1})) { piece.y++; score+=1; updateUI(); } else { lockPiece(); } }
function hardDrop(){
  let steps=0; while(!collides({...piece, y: piece.y+1})) { piece.y++; steps++; }
  score += steps*2; updateUI(); lockPiece();
}
function lockPiece(){
  merge(piece);
  const cleared = clearLines();
  if(cleared){ playLineClear(cleared);
    if(cleared === 3){ tripleBanner.classList.add("show"); setTimeout(()=>tripleBanner.classList.remove("show"), 650); }
    else if(cleared === 4){ tetrisBanner.classList.add("show"); setTimeout(()=>tetrisBanner.classList.remove("show"), 900); }
    else { canvas.classList.add("flash"); setTimeout(()=>canvas.classList.remove("flash"), 140); }
  }
  spawnNext();
  dropInterval = Math.max(160, 700 - Math.floor(score/800)*40); // gradual speed curve
}
function spawnNext(){
  piece = nextPiece;
  piece.x = 3; piece.y = 0;
  canHold = true;
  nextPiece = newPiece(randType());
  drawNext();
  if(collides(piece)){ gameOver(); }
}
function holdPiece(){
  if(!canHold) return;
  if(holdType==null){
    holdType = piece.type;
    piece = nextPiece;
    piece.x=3; piece.y=0;
    nextPiece = newPiece(randType());
  } else {
    const tmp = holdType; holdType = piece.type; piece = newPiece(tmp);
  }
  canHold = false; drawHold(); drawNext();
}

/* ===== Lines ===== */
function clearLines(){
  let cleared = 0;
  const newBoard = [];
  for(let y=0;y<ROWS;y++){
    if(board[y].every(v=>v!==0)) cleared++;
    else newBoard.push(board[y]);
  }
  while(newBoard.length < ROWS) newBoard.unshift(Array(COLS).fill(0));
  if(cleared>0){
    score += [0,100,300,500,800][cleared];
    lines += cleared;
    if(score>highScore){ highScore=score; localStorage.setItem("gepetris_high", String(highScore)); }
    updateUI();
  }
  board = newBoard;
  return cleared;
}
function updateUI(){ scoreEl.textContent = score; highScoreEl.textContent = String(highScore); linesEl.textContent = lines; }

/* ===== Lifecycle ===== */
function startGame(){
  resetBoard();
  holdType = null; drawHold();
  piece = newPiece(randType());
  nextPiece = newPiece(randType());
  drawNext();
  score=0; lines=0; updateUI();
  isPaused=false; isGameOver=false;
  dropInterval=700; dropCounter=0; lastTime=performance.now();
  pauseOverlay.classList.add("hidden");
  gameOverOverlay.classList.add("hidden");
  pauseButton.disabled = false;
  ensureAudio();
  requestAnimationFrame(loop);
}
function gameOver(){ isGameOver = true; holdType=null; drawHold(); gameOverOverlay.classList.remove("hidden"); }
function togglePause(){ if(isGameOver) return; isPaused = !isPaused; pauseOverlay.classList.toggle("hidden", !isPaused); if(!isPaused){ lastTime = performance.now(); requestAnimationFrame(loop);} }

/* ===== Loop with DAS & soft-repeat ===== */
const DAS_DELAY = 160, DAS_REPEAT = 50, SOFT_RATE = 55;
let leftHeld=false, rightHeld=false, downHeld=false;
let leftAcc=0, rightAcc=0, downAcc=0;
function loop(t){
  if(isPaused || isGameOver) return;
  const delta = t - lastTime; lastTime = t;
  // gravity
  dropCounter += delta; if(dropCounter >= dropInterval){ softDropOnce(); dropCounter = 0; }
  // DAS left
  if(leftHeld){ leftAcc += delta; if(leftAcc>=DAS_DELAY){ movePiece(-1); leftAcc -= DAS_REPEAT; if(leftAcc>DAS_DELAY) leftAcc=DAS_DELAY; } }
  // DAS right
  if(rightHeld){ rightAcc += delta; if(rightAcc>=DAS_DELAY){ movePiece(1); rightAcc -= DAS_REPEAT; if(rightAcc>DAS_DELAY) rightAcc=DAS_DELAY; } }
  // soft drop
  if(downHeld){ downAcc += delta; while(downAcc>=SOFT_RATE){ softDropOnce(); downAcc -= SOFT_RATE; } }
  // render
  drawBoard(); drawGhost(piece); drawPiece(piece);
  requestAnimationFrame(loop);
}

/* ====================== INPUT: KEYBOARD (multi-key) ====================== */
const blockKeys = new Set(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"]);
addEventListener("keydown", (e)=>{ if(blockKeys.has(e.code)) e.preventDefault(); });
const held = new Set();

document.addEventListener("keydown",(e)=>{
  if(held.has(e.code)) return; held.add(e.code); ensureAudio(); if(isGameOver) return;
  switch(e.code){
    case "ArrowLeft": leftHeld=true; leftAcc=0; movePiece(-1); rightHeld=false; break;
    case "ArrowRight": rightHeld=true; rightAcc=0; movePiece(1); leftHeld=false; break;
    case "ArrowDown": downHeld=true; downAcc=SOFT_RATE; break;
    case "ArrowUp": rotateCCW(); break; // inverted rotation on Up
    case "KeyZ": rotateCCW(); break;
    case "KeyX": rotateCW(); break;
    case "Space": hardDrop(); break;
    case "KeyC": holdPiece(); break;
    case "KeyP": togglePause(); break;
  }
});

document.addEventListener("keyup",(e)=>{
  held.delete(e.code);
  switch(e.code){
    case "ArrowLeft": leftHeld=false; leftAcc=0; break;
    case "ArrowRight": rightHeld=false; rightAcc=0; break;
    case "ArrowDown": downHeld=false; downAcc=0; break;
  }
});

startButton.onclick = ()=> startGame();
restartButton.onclick = ()=> startGame();
pauseButton.onclick = ()=> togglePause();

/* ====================== INPUT: GAMEPAD ====================== */
let gamepadIndex = null; let prevButtons = [];
window.addEventListener("gamepadconnected", (e)=>{ gamepadIndex=e.gamepad.index; gpStatus.textContent = "ðŸŽ® "+e.gamepad.id; prevButtons = e.gamepad.buttons.map(b=>b.pressed); requestAnimationFrame(pollGamepad); });
window.addEventListener("gamepaddisconnected", ()=>{ gpStatus.textContent = "ðŸŽ® No Controller"; gamepadIndex=null; });
function pollGamepad(){
  if(gamepadIndex===null) return; const gp = navigator.getGamepads()[gamepadIndex]; if(!gp){ requestAnimationFrame(pollGamepad); return; }
  const now = performance.now();
  const p = (i)=> gp.buttons[i] && gp.buttons[i].pressed;
  const edge = (i)=> p(i) && !prevButtons[i];
  // D-Pad
  if(p(14)){ if(!leftHeld){ leftHeld=true; leftAcc=0; movePiece(-1); rightHeld=false; } } else { leftHeld=false; }
  if(p(15)){ if(!rightHeld){ rightHeld=true; rightAcc=0; movePiece(1); leftHeld=false; } } else { rightHeld=false; }
  if(p(13)){ downHeld=true; } else { downHeld=false; }
  // A/B rotate, Y hold, X hard drop
  if(edge(0)) rotateCW();
  if(edge(1)) rotateCCW();
  if(edge(3)) holdPiece();
  if(edge(2)) hardDrop();
  // Select pause (8), Start restart/resume (9)
  if(edge(8)) togglePause();
  if(edge(9)) { if(isGameOver) startGame(); else if(isPaused) togglePause(); }
  prevButtons = gp.buttons.map(b=>!!b.pressed);
  requestAnimationFrame(pollGamepad);
}

/* ====================== INIT ====================== */
highScoreEl.textContent = highScore.toString();
</script>
</body>
</html>
