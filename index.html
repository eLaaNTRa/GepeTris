<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GePetris</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Press Start 2P', cursive; background: linear-gradient(135deg,#0d1117,#161b22); color: white; }
    .tetris-grid{ border:4px solid #4a5568; border-radius:8px; box-shadow:0 0 20px rgba(74,85,104,0.4); background:#000; }
    .tetris-panel{ background:#161b22; border:2px solid #4a5568; border-radius:8px; }
    #tetrisBanner,#tripleBanner{ color:#FFE138; text-shadow:-2px -2px 0 #FF8E0D,2px -2px 0 #FF8E0D,-2px 2px 0 #FF8E0D,2px 2px 0 #FF8E0D,-3px -3px 0 #FF0D72,3px -3px 0 #FF0D72,-3px 3px 0 #FF0D72,3px 3px 0 #FF0D72; opacity:0; transform:translateY(-8px) scale(0.85); transition:all .45s cubic-bezier(.2,1,.2,1); pointer-events:none; }
    #tetrisBanner.show,#tripleBanner.show{ opacity:1; transform:translateY(0) scale(1); }
    .flash{ animation: flash .12s ease-in-out 2; }
    @keyframes flash{ 0%,100%{ filter:brightness(1); } 50%{ filter:brightness(1.35); } }
    #gpStatus { position: fixed; right: 12px; bottom: 8px; font-family: monospace; font-size: 12px; opacity: 0.75; color: #ddd; }
    footer { position: fixed; bottom: 8px; left: 12px; font-size: 10px; color: #aaa; }
  </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4">
  <div class="w-full max-w-4xl mx-auto flex flex-col lg:flex-row gap-4">

    <!-- Left Panel -->
    <div class="w-full lg:w-1/4 flex flex-row lg:flex-col gap-4">
      <div class="tetris-panel p-4 w-1/2 lg:w-full text-center">
        <h2 class="text-lg mb-2">HOLD</h2>
        <canvas id="holdCanvas" width="120" height="120" class="mx-auto bg-black rounded-md"></canvas>
      </div>
      <div class="tetris-panel p-4 w-1/2 lg:w-full text-center">
        <h2 class="text-lg mb-2">SCORE</h2>
        <p id="score" class="text-2xl">0</p>
        <h2 class="text-lg mt-4 mb-2">BEST</h2>
        <p id="highScore" class="text-2xl">0</p>
        <h2 class="text-lg mt-4 mb-2">LINES</h2>
        <p id="lines" class="text-2xl">0</p>
      </div>
    </div>

    <!-- Center -->
    <div class="relative">
      <canvas id="tetris" width="300" height="600" class="tetris-grid"></canvas>
      <div id="pauseOverlay" class="absolute inset-0 bg-black bg-opacity-75 flex items-center justify-center text-4xl hidden">PAUSED</div>
      <div id="gameOverOverlay" class="absolute inset-0 bg-black bg-opacity-75 flex flex-col items-center justify-center text-4xl hidden">
        <p>GAME OVER</p>
        <button id="restartButton" class="tetris-button bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded mt-4 text-lg">RESTART</button>
      </div>
      <div id="tetrisBanner" class="absolute inset-0 flex items-start justify-center pt-8 text-4xl font-bold">Boom! Tetris!</div>
      <div id="tripleBanner" class="absolute inset-0 flex items-start justify-center pt-12 text-3xl font-bold">Triple Clear!</div>
    </div>

    <!-- Right Panel -->
    <div class="w-full lg:w-1/4 flex flex-col gap-4">
      <div class="tetris-panel p-4 text-center">
        <h2 class="text-lg mb-2">NEXT</h2>
        <canvas id="nextCanvas" width="120" height="120" class="mx-auto bg-black rounded-md"></canvas>
      </div>
      <div class="tetris-panel p-4">
        <h2 class="text-lg mb-3 text-center">CONTROLS</h2>
        <div class="flex flex-col gap-4">
          <button id="startButton" class="tetris-button bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded">START</button>
          <button id="pauseButton" class="tetris-button bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-4 rounded" disabled>PAUSE</button>
          <button id="rotationToggle" class="tetris-button bg-pink-500 hover:bg-pink-600 text-white font-bold py-3 px-4 rounded">Switch Rotation Mode</button>
        </div>
        <div class="text-xs mt-4 space-y-2 text-gray-400">
          <p><span class="font-bold text-white">Keyboard:</span> Arrows = Move, Space = Hard Drop, Z/X = Rotate, C = Hold, P = Pause</p>
          <p><span class="font-bold text-white">Controller:</span> D-Pad = Move, A = CW, B = CCW, Y = Hold, X = Hard Drop, Select = Pause, Start = Restart</p>
        </div>
      </div>
    </div>

  </div>
  <div id="gpStatus">ðŸŽ® No Controller</div>
  <footer>Vibe-Coded by: Pranav Kulkarni aka eLaNTRa</footer>

<script>
/* ========= Sound ========= */
const AudioCtx = window.AudioContext||window.webkitAudioContext;
let audioCtx=null;
function ensureAudio(){ if(!audioCtx) audioCtx=new AudioCtx(); }
function beep({freq=880,dur=60,vol=0.12,type='square'}){ ensureAudio(); const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type=type; o.frequency.setValueAtTime(freq,audioCtx.currentTime); g.gain.setValueAtTime(vol,audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+dur/1000); o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime+dur/1000); }
function sfxMove(){ beep({freq:900,dur:60,vol:0.12,type:'square'}); }
const sfxRotate = sfxMove; // rotation uses the exact same sound as move
function playHardDrop(){ beep({freq:600,dur:80,vol:0.25}); setTimeout(()=>beep({freq:400,dur:100,vol:0.2}),40); }
function playLineClear(n){ let base=440; if(n==1) beep({freq:base,dur:120,vol:0.2}); else if(n==2){ beep({freq:base,dur:100,vol:0.22}); setTimeout(()=>beep({freq:base*1.5,dur:110,vol:0.24}),120); } else if(n==3){ setTimeout(()=>beep({freq:base,dur:90,vol:0.22}),0); setTimeout(()=>beep({freq:base*1.25,dur:90,vol:0.22}),110); setTimeout(()=>beep({freq:base*1.5,dur:110,vol:0.24}),220); } else if(n==4){ beep({freq:120,dur:300,vol:0.42,type:'sawtooth'}); setTimeout(()=>beep({freq:240,dur:150,vol:0.3,type:'square'}),100); }
}

/* ========= Controller Vibration ========= */
function rumble(ms=200,strong=1.0,weak=1.0){ const gp = navigator.getGamepads()[0]; if(gp && gp.vibrationActuator && gp.vibrationActuator.playEffect){ try{ gp.vibrationActuator.playEffect('dual-rumble',{duration:ms,strongMagnitude:strong,weakMagnitude:weak}); }catch(e){} } }

/* ========= Game engine (full single-file) ========= */
const COLS=10, ROWS=20, SIZE=30; const MINI=24;
const COLORS=['#000','#FF0D72','#0DC2FF','#0DFF72','#F538FF','#FF8E0D','#FFE138','#3877FF'];
const SHAPES={ 1:[[1,1,1,1]], 2:[[2,2],[2,2]], 3:[[0,3,0],[3,3,3]], 4:[[0,4,4],[4,4,0]], 5:[[5,5,0],[0,5,5]], 6:[[6,0,0],[6,6,6]], 7:[[0,0,7],[7,7,7]] };

let board, piece, nextPiece, holdType=null, canHold=true;
let score=0, lines=0, highScore=Number(localStorage.getItem('gepetris_high')||0);
let isPaused=false, isGameOver=false;
let dropCounter=0, dropInterval=650, lastTime=0;
let upRotatesCW=false;

const canvas = document.getElementById('tetris'), ctx = canvas.getContext('2d');
const nextCanvas = document.getElementById('nextCanvas'), nextCtx = nextCanvas.getContext('2d');
const holdCanvas = document.getElementById('holdCanvas'), holdCtx = holdCanvas.getContext('2d');
const scoreEl = document.getElementById('score'), highScoreEl = document.getElementById('highScore'), linesEl = document.getElementById('lines');
const pauseOverlay = document.getElementById('pauseOverlay'), gameOverOverlay = document.getElementById('gameOverOverlay');
const restartButton = document.getElementById('restartButton'), pauseButton = document.getElementById('pauseButton'), startButton = document.getElementById('startButton');
const tetrisBanner = document.getElementById('tetrisBanner'), tripleBanner = document.getElementById('tripleBanner');
const rotationToggle = document.getElementById('rotationToggle'); const gpStatus = document.getElementById('gpStatus');

function cloneShape(s){ return s.map(r=>r.slice()); }
function resetBoard(){ board = Array.from({length:ROWS},()=>Array(COLS).fill(0)); }
function randType(){ return 1 + Math.floor(Math.random()*7); }
function newPiece(type){ return { type, shape: cloneShape(SHAPES[type]), x:3, y:0 }; }

function drawBlock(ctx2,x,y,colorIndex,size=SIZE,alpha=1){ if(y<0) return; ctx2.save(); ctx2.globalAlpha = alpha; ctx2.fillStyle = COLORS[colorIndex]; ctx2.fillRect(x*size,y*size,size,size); ctx2.strokeStyle = '#111'; ctx2.lineWidth = 1; ctx2.strokeRect(x*size,y*size,size,size); ctx2.restore(); }
function drawBoard(){ ctx.clearRect(0,0,canvas.width,canvas.height); for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) if(board[y][x]) drawBlock(ctx,x,y,board[y][x]); }
function drawPiece(p){ p.shape.forEach((row,dy)=>row.forEach((v,dx)=>{ if(v) drawBlock(ctx,p.x+dx,p.y+dy,v); })); }
function drawGhost(p){ const g={ x:p.x, y:p.y, shape:p.shape, type:p.type }; while(!collides({...g,y:g.y+1})) g.y++; g.shape.forEach((row,dy)=>row.forEach((v,dx)=>{ if(v) drawBlock(ctx,g.x+dx,g.y+dy,v,SIZE,0.28); })); }
function drawMini(canvasCtx,type){ canvasCtx.clearRect(0,0,canvasCtx.canvas.width,canvasCtx.canvas.height); if(!type) return; const s=SHAPES[type]; const w=s[0].length,h=s.length; const offX=Math.floor((canvasCtx.canvas.width - w*MINI)/2); const offY=Math.floor((canvasCtx.canvas.height - h*MINI)/2); s.forEach((row,y)=>row.forEach((v,x)=>{ if(v){ canvasCtx.fillStyle = COLORS[v]; canvasCtx.fillRect(offX + x*MINI, offY + y*MINI, MINI, MINI); canvasCtx.strokeStyle = '#111'; canvasCtx.strokeRect(offX + x*MINI, offY + y*MINI, MINI, MINI); } })); }

function collides(p){ return p.shape.some((row,dy)=>row.some((v,dx)=>{ if(!v) return false; const nx = p.x+dx, ny = p.y+dy; if(nx<0||nx>=COLS||ny>=ROWS) return true; if(ny<0) return false; return !!board[ny][nx]; })); }
function merge(p){ p.shape.forEach((row,dy)=>row.forEach((v,dx)=>{ const nx=p.x+dx, ny=p.y+dy; if(v && ny>=0) board[ny][nx] = v; })); }

function rotCW(s){ return s[0].map((_,i)=>s.map(r=>r[i]).reverse()); }
function rotCCW(s){ return s[0].map((_,i)=>s.map(r=>r[r.length-1-i])); }
function tryRotate(newShape){ const tests=[[0,0],[1,0],[-1,0],[2,0],[-2,0],[0,-1]]; for(const [ox,oy] of tests){ const t={ ...piece, x: piece.x+ox, y: piece.y+oy, shape: newShape }; if(!collides(t)){ piece.x += ox; piece.y += oy; piece.shape = newShape; sfxMove(); return true; } } return false; }
function rotateCW(){ tryRotate(rotCW(cloneShape(piece.shape))); }
function rotateCCW(){ tryRotate(rotCCW(cloneShape(piece.shape))); }

function movePiece(dx){ const t={ ...piece, x: piece.x + dx }; if(!collides(t)){ piece.x += dx; sfxMove(); return true; } return false; }
function softDropOnce(){ const t={ ...piece, y: piece.y + 1 }; if(!collides(t)){ piece.y++; score++; updateUI(); } else { lockPiece(); } }
function hardDrop(){ let steps=0; while(!collides({...piece,y:piece.y+1})){ piece.y++; steps++; } score += steps*2; playHardDrop(); updateUI(); lockPiece(); }

function spawnNext(){ piece = nextPiece; piece.x = 3; piece.y = 0; canHold = true; nextPiece = newPiece(randType()); drawMini(nextCtx,nextPiece.type); if(collides(piece)) gameOver(); }
function holdPiece(){ if(!canHold) return; if(holdType==null){ holdType = piece.type; piece = nextPiece; piece.x=3; piece.y=0; nextPiece = newPiece(randType()); } else { const tmp = holdType; holdType = piece.type; piece = newPiece(tmp); } canHold = false; drawMini(holdCtx,holdType); drawMini(nextCtx,nextPiece.type); }

function clearLines(){ let cleared = 0; const nb = []; for(let y=0;y<ROWS;y++){ if(board[y].every(v=>v)) cleared++; else nb.push(board[y]); } while(nb.length<ROWS) nb.unshift(Array(COLS).fill(0)); board = nb; if(cleared){ score += [0,100,300,500,800][cleared]; lines += cleared; if(score>highScore){ highScore = score; localStorage.setItem('gepetris_high',String(highScore)); } updateUI(); playLineClear(cleared); if(cleared===3){ tripleBanner.classList.add('show'); setTimeout(()=>tripleBanner.classList.remove('show'),650); } else if(cleared===4){ tetrisBanner.classList.add('show'); setTimeout(()=>tetrisBanner.classList.remove('show'),900); rumble(420,1.0,1.0); } else { canvas.classList.add('flash'); setTimeout(()=>canvas.classList.remove('flash'),140); }
    dropInterval = Math.max(140,650 - Math.floor(score/800)*40);
  }
}
function lockPiece(){ merge(piece); clearLines(); spawnNext(); }

function updateUI(){ scoreEl.textContent = String(score); linesEl.textContent = String(lines); highScoreEl.textContent = String(highScore); }
function startGame(){ resetBoard(); holdType=null; holdCtx.clearRect(0,0,holdCanvas.width,holdCanvas.height); piece=newPiece(randType()); nextPiece=newPiece(randType()); drawMini(nextCtx,nextPiece.type); score=0; lines=0; updateUI(); isPaused=false; isGameOver=false; dropInterval=650; dropCounter=0; lastTime=performance.now(); pauseOverlay.classList.add('hidden'); gameOverOverlay.classList.add('hidden'); pauseButton.disabled=false; ensureAudio(); requestAnimationFrame(loop); }
function gameOver(){ isGameOver=true; holdType=null; holdCtx.clearRect(0,0,holdCanvas.width,holdCanvas.height); gameOverOverlay.classList.remove('hidden'); }
function togglePause(){ if(isGameOver) return; isPaused = !isPaused; pauseOverlay.classList.toggle('hidden',!isPaused); if(!isPaused){ lastTime = performance.now(); requestAnimationFrame(loop); } }
rotationToggle.onclick = () => { upRotatesCW = !upRotatesCW; rotationToggle.textContent = upRotatesCW ? 'Up = CW (switch)' : 'Up = CCW (switch)'; };

/* ======= DAS implementation (fixed) ======= */
const DAS_DELAY = 170, DAS_REPEAT = 45, SOFT_RATE = 55;
let leftHeld=false, rightHeld=false, downHeld=false;
let leftNext=null, rightNext=null, downNext=null;

function loop(ts){ if(isPaused || isGameOver) return; const now = ts; const dt = now - lastTime; lastTime = now; dropCounter += dt; if(dropCounter >= dropInterval){ softDropOnce(); dropCounter -= dropInterval; }
  // LEFT
  if(leftHeld){ if(leftNext==null) leftNext = now + DAS_DELAY; else if(now >= leftNext){ movePiece(-1); leftNext = now + DAS_REPEAT; } } else { leftNext = null; }
  // RIGHT
  if(rightHeld){ if(rightNext==null) rightNext = now + DAS_DELAY; else if(now >= rightNext){ movePiece(1); rightNext = now + DAS_REPEAT; } } else { rightNext = null; }
  // DOWN (soft drop repeat)
  if(downHeld){ if(downNext==null){ softDropOnce(); downNext = now + SOFT_RATE; } else if(now >= downNext){ softDropOnce(); downNext = now + SOFT_RATE; } } else { downNext = null; }
  // render
  drawBoard(); if(piece) { drawGhost(piece); drawPiece(piece); }
  requestAnimationFrame(loop);
}

/* ====================== INPUT: KEYBOARD ====================== */
const heldKeys = new Set(); const stopRepeat = new Set(['ArrowLeft','ArrowRight','ArrowDown','ArrowUp','Space','KeyZ','KeyX','KeyC']);
addEventListener('keydown',e=>{ if(stopRepeat.has(e.code)) e.preventDefault(); });

document.addEventListener('keydown',e=>{ if(heldKeys.has(e.code)) return; heldKeys.add(e.code); ensureAudio(); if(e.code==='Enter'){ startGame(); return; } if(e.code==='KeyP'){ togglePause(); return; } if(isGameOver||isPaused) return; const now = performance.now(); switch(e.code){ case 'ArrowLeft': leftHeld=true; movePiece(-1); rightHeld=false; leftNext = now + DAS_DELAY; rightNext = null; break; case 'ArrowRight': rightHeld=true; movePiece(1); leftHeld=false; rightNext = now + DAS_DELAY; leftNext = null; break; case 'ArrowDown': downHeld=true; softDropOnce(); downNext = now + SOFT_RATE; break; case 'ArrowUp': upRotatesCW ? rotateCW() : rotateCCW(); break; case 'KeyZ': rotateCCW(); break; case 'KeyX': rotateCW(); break; case 'Space': hardDrop(); break; case 'KeyC': holdPiece(); break; } });

document.addEventListener('keyup',e=>{ heldKeys.delete(e.code); switch(e.code){ case 'ArrowLeft': leftHeld=false; leftNext=null; break; case 'ArrowRight': rightHeld=false; rightNext=null; break; case 'ArrowDown': downHeld=false; downNext=null; break; } });

/* ====================== INPUT: MOUSE ====================== */
canvas.addEventListener('contextmenu',e=>e.preventDefault());
canvas.addEventListener('dblclick',()=>{ if(!isPaused && !isGameOver) hardDrop(); });
canvas.addEventListener('click',e=>{ ensureAudio(); if(isPaused||isGameOver) return; const rect = canvas.getBoundingClientRect(); const x = e.clientX-rect.left; const third = rect.width/3; if(x < third) { movePiece(-1); leftNext = performance.now() + DAS_DELAY; rightNext = null; } else if(x > 2*third) { movePiece(1); rightNext = performance.now() + DAS_DELAY; leftNext = null; } else { rotateCW(); } });
canvas.addEventListener('wheel',e=>{ if(isPaused||isGameOver) return; e.deltaY < 0 ? rotateCW() : rotateCCW(); });

/* ====================== BUTTONS ====================== */
startButton.onclick = ()=> startGame(); restartButton.onclick = ()=> startGame(); pauseButton.onclick = ()=> togglePause();

/* ====================== GAMEPAD ====================== */
let prevButtons = [];
function edge(gp,i){ return gp.buttons[i] && gp.buttons[i].pressed && !prevButtons[i]; }
window.addEventListener('gamepadconnected',e=>{ activePadIndex = e.gamepad.index; gpStatus.textContent = 'ðŸŽ® ' + e.gamepad.id; prevButtons = e.gamepad.buttons.map(b=>!!b.pressed); requestAnimationFrame(pollPad); });
window.addEventListener('gamepaddisconnected',()=>{ gpStatus.textContent = 'ðŸŽ® No Controller'; activePadIndex = null; });

function pollPad(){ if(activePadIndex==null) return; const gp = navigator.getGamepads()[activePadIndex]; if(!gp){ requestAnimationFrame(pollPad); return; }
  const now = performance.now();
  // D-pad Left (14)
  if(gp.buttons[14]?.pressed){ if(!leftHeld){ leftHeld = true; movePiece(-1); rightHeld = false; leftNext = now + DAS_DELAY; rightNext = null; } } else { leftHeld = false; leftNext = null; }
  // D-pad Right (15)
  if(gp.buttons[15]?.pressed){ if(!rightHeld){ rightHeld = true; movePiece(1); leftHeld = false; rightNext = now + DAS_DELAY; leftNext = null; } } else { rightHeld = false; rightNext = null; }
  // D-pad Down (13)
  if(gp.buttons[13]?.pressed){ if(!downHeld){ downHeld = true; softDropOnce(); downNext = now + SOFT_RATE; } } else { downHeld = false; downNext = null; }
  // buttons: A=0, B=1, X=2, Y=3
  if(edge(gp,0)) rotateCW(); if(edge(gp,1)) rotateCCW(); if(edge(gp,2)) hardDrop(); if(edge(gp,3)) holdPiece();
  // Select=8 Pause, Start=9 Restart
  if(edge(gp,8)) togglePause(); if(edge(gp,9)){ if(isGameOver) startGame(); else if(isPaused) togglePause(); }
  prevButtons = gp.buttons.map(b=>!!b.pressed);
  requestAnimationFrame(pollPad);
}

/* ====================== BOOT ====================== */
highScoreEl.textContent = String(highScore);
resetBoard(); piece = newPiece(randType()); nextPiece = newPiece(randType()); drawMini(nextCtx,nextPiece.type); render();

</script>
</body>
</html>
